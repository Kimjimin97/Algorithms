import xdrlib


N = int(input())

sand_graph = []

for _ in range(N):
    sand_graph.append(list(map(int, input().split())))

dxy = [[0,-1],[1,0],[0,1],[-1,0]]

rotate = {
    0:  [[-2,0,0,0.02], [ -1,-1,0.1],[-1,0,0.07],[-1,1,0.01],[0,-2,-0.05],[1,-1,0.1],[1,0,0.7],[1,1,0.01],[2,0,0.02]],
    1:  [[0,-2,0,0.02], [ -1,-1,0.1],[0,-1,0.07],[1,-1,0.01],[2,0,-0.05],[1,1,0.1],[0,1,0.7],[-1,1,0.01],[0,2,0.02]],
    2:  [[-2,0,0,0.02], [ -1,-1,0.1],[-1,0,0.07],[-1,1,0.01],[0,2,-0.05],[1,-1,0.1],[1,0,0.7],[1,1,0.01],[2,0,0.02]],
    3:  [[0,-2,0,0.02], [ 1,-1,0.1],[0,-1,0.07],[-1,-1,0.01],[2,0,-0.05],[1,1,0.1],[0,1,0.7],[-1,1,0.01],[0,2,0.02]]
}


if N% 2 == 0:
    x,y = N//2, N//2
else:
    x,y = N//2 +1, N//2 +1

n = 0

def sand_move(x,y,k):
    nx += dxy[k][0]
    ny += dxy[k][1]

    for i in range(8):
        sand_graph[]

    return

def mobe(l,k):
    global x
    global y
    for _ in range(l):
        x,y = x+dxy[k][0], y+ dxy[k][1]
        sand_move(x,y,k)

    return


for _ in range(N//2):
    n += 2
    for k in range(4):
        mobe(n-1,k)

